var timeUtils = (function(w,d,c){
    var interpretTimeStr, getTimes, getTimesDispatcher, 
        formatTimeStr, formatTimeStrDispatcher; 

    var exports = { }; 


    if (!Date.prototype.toISOString) {
      (function() {
        function pad(number) {
          var r = String(number);
          if ( r.length === 1 ) {
            r = '0' + r;
          }
          return r;
        }
        Date.prototype.toISOString = function() {
          return this.getUTCFullYear()
            + '-' + pad( this.getUTCMonth() + 1 )
            + '-' + pad( this.getUTCDate() )
            + 'T' + pad( this.getUTCHours() )
            + ':' + pad( this.getUTCMinutes() )
            + ':' + pad( this.getUTCSeconds() )
            + '.' + String( (this.getUTCMilliseconds()/1000).toFixed(3) ).slice( 2, 5 )
            + 'Z';
        };
      }());
    }


    interpretTimeStr = function(time,date) { 
      time = { timeing: time, arr: time.split(':') }; 
      time.hours = parseInt(time.arr[0]); 
      time.minutes = parseInt(time.arr[1].substring(0,2)); 
      time.pm = (jDom.trim(time.arr[1].substring(2,time.arr[1].length)).toLowerCase() == 'pm'); 
      time.militaryhours = (time.pm && time.hours != 12) ? 12 + time.hours : time.hours;
      time.militaryhours = (!time.pm && time.hours == 12) ? 0 : time.militaryhours; 
      date.setHours(time.militaryhours); date.setMinutes(time.minutes); date.setSeconds(0);
      time.date = date.setMilliseconds(0); 
      time.totalminutes = time.militaryhours * 60 + time.minutes; 
      return time; 
    }; 
    
    getTimes = function(start,end,delta,date) { 
      date = (typeof date == 'undefined') ? new Date() : date; 
      start = interpretTimeStr(start,date); 
      end = interpretTimeStr(end,date); 
      var numsteps = ((end.totalminutes - start.totalminutes) / delta) + 1; 
      var arr = []; 
      for(var i=0; i < numsteps; ++i) { 
        arr.push(new Date(start.date + (60000 * (i*delta))))
      }
      return arr; 
    }
    exports.getTimes = function(start,end,delta,date) { return getTimes(start,end,delta,date); }; 
    
    formatTimeStr = function(date,short) { 
        if(date) { 
          var hrs, mins, pm, str; 
          short = (typeof short == 'undefined') ? false : short; 
          hrs = date.getHours(); 
          pm = (hrs > 11) ? true : false; 
          hrs -= (hrs!=0 && pm) ? 12 : 0;
          hrs = (hrs==0) ? 12 : hrs; 
          mins = date.getMinutes(); 
          mins = (mins < 10) ? "0" + mins : mins; 
          pm = (pm) ? "pm" : "am"; 
          if(short) { 
              str = hrs + pm; 
          } else {
              str = hrs + ":" + mins + " " + pm; 
          }
          return str; 
        } else { 
          return false;
        }
    }; 
    exports.formatTimeStr = function(date,short) { return formatTimeStr(date,short); }; 

    return exports;
    
})(window,document,console); 
// some utilities wrapped up in bows: 
var jDom = (function(exports,w,d,c){
    /* ================================================

        Our Public Functions: 
            
            1) UTILITY FUNCTIONS: 
            -jDom.extend(object,object,...)
            -jDon.trim(str,str,str,...,str)
            -jDom.getKeys(obj) 
                for getting Object.keys(obj)    
                (includes a polyfill of sorts for old browsers)
            -isArray(testObj)

            2) DOM EVENTS: 
            -jDom.ready(function)
                enqueues loadEvents on domready
            -jDom.on(element,eventTypes,func)
                eventTypes can be space separated list of events
                events are 'mouseover','click','focus',... (not 'onmouseover', 'onclick', etc..)
            -jDom.trigger(context,eventType)
            
            3) DOM MANIPULATION/CREATION: 
            -jDom.create(String | {})
                create a dom node as specified via obj 
                (load jDom.interpret for emmet.io-like interpretation)
            
            4) DOM GETTERS/SETTERS: 
            -jDom.getByClassName(classes,context)
                classes is space separated values
                context is an element (not required) 
            -jDom.getElementsByData(key,val,context,type);
            -jDom.getData(elem)
            -jDom.addClass(elem,classes) 
                classes is space separated string
            -jDom.removeClass(elem,classes) 
                elem is an array of elements or a single element
                classes is space separated string

    ================================================ */

    /*=========================================================
    |   1) UTILITY FUNCTIONS:                                 |
    ======================================================== */ 
    exports.extend = function() { 
        /* 
            this extend can handle nested objects & any 
            number of objects passed as arguments
        */
        return extend(arguments); 
    }; 
    exports.trim = function() { 
        var results = []; 
        for(var i=0; i < arguments.length; ++i) { 
            results.push(trim(arguments[i])); 
        }
        return (results.length > 1) ? results : results[0]; 
    }; 
    exports.getKeys = function(obj) { 
        return getKeys(obj); 
    }; 
    exports.isArray = function(testObj) { 
        if(typeof testObj == 'object') { 
            return isObjectAnArray(testObj); 
        } else { 
            return false; 
        }
    }; 


    /*=========================================================
    |   2) DOM EVENTS:                                        |
    ======================================================== */ 
    exports.ready = function(func) { 
        var oldonload = w.onload;
        if (typeof w.onload != 'function' ) {
            w.onload = func;
        } else {
            w.onload = function() {
                oldonload();
                func();
            }
        }
    }; 
    exports.trigger = function(context,eventType) { 
        return trigger(context,eventType); 
    }; 
    exports.on = function(elem,eventTypes,func) { 
        eventTypes = getArrayFromSpaceSeparated(eventTypes); 
        for(var i=0; i < eventTypes.length; ++i) { 
            addEvent(elem,eventTypes[i],func); 
        }
        return elem; 
    }; 


    /*=========================================================
    |   3) DOM MANIPULATION/CREATION:                         |
    ======================================================== */ 
    exports.create = function(obj) {
        return create(obj);
    };

    /*=========================================================
    |   4) DOM GETTERS/SETTERS:                               |
    ======================================================== */ 
    exports.getByClassName = function(str,context) { 
        var elems = [ ]; 
        context = (typeof context == 'undefined') ? d : context; 
        if(d.getElementsByClassName) { 
            return elems = context.getElementsByClassName(str); 
        } else { 
            return getByClassName(str,context); 
        }
    }; 
    exports.getElementsByData = function(key,val,context,type) { 
        val = (typeof val == 'undefined') ? null : val; 
        context = (typeof context == 'undefined') ? d : context; 
        type = (typeof type == 'undefined') ? '*' : type; 
        return getElementsByData(key,val,context,type); 
    }; 
    exports.getData = function(elem) { 
        var attrs, keys, data = { }; 
        attrs = getAttrs(elem); 
        keys = getKeys(attrs); 
        for(var i=0; i < keys.length; ++i) { 
            if(keys[i].indexOf('data-') == 0) { 
                data[keys[i].substring(5,keys[i].length)] = attrs[keys[i]]; 
            }
        }
        return data; 
    }; 
    exports.addClass = function(elem,classes) { 
        var currentClasses = ""; 
        if(typeof elem.className != 'undefined') { 
            currentClasses = ' ' + getArrayFromSpaceSeparated(elem.className).join(' ') + ' '; 
            classes = getArrayFromSpaceSeparated(classes); 
            for(var i=0; i < classes.length; ++i) { 
                if(currentClasses.indexOf(' ' + classes[i] + ' ') < 0) { 
                    currentClasses += classes[i] + ' '; 
                }
            }
            elem.className = trim(currentClasses); 
        } else { 
            elem.className = trim(classes); 
        }
        return elem; 
    }; 
    exports.removeClass = function(elem,classes,single) { 
        single = (typeof single == 'undefined') ? true : false; 
        if(single) { 
            return removeClass(elem,classes); 
        } else {
            var arr = [];  
            for(var i=0; i < elem.length; ++i) { 
                arr.push(removeClass(elem[i],classes)); 
            }
            return arr; 
        }
    }; 


    /* ================================================ 
        Our Private Methods:
            1) UTILITY FUNCTIONS: 
                -extend()
                -trim()
                -getKeys()
                -getArrayFromSpaceSeparated()
                -isObjectAnArray()
            2) DOM EVENTS: 
                -trigger()
                -addEvent()
            3) DOM MANIPULATION/CREATION: 
                -creator()
                -createElem()
            4) DOM GETTERS/SETTERS: 
                -getByClassName()
                -getElementsByData()
                -getAttrs()
                -removeClass(); 
    ================================================ */


    /*=========================================================
    |   1) UTILITY FUNCTIONS:                                 |
    ======================================================== */ 
    var extend, trim, getKeys, getArrayFromSpaceSeparated, isObjectAnArray; 
    extend = function(args) { 
        for(var i=args.length-1; i > 0; --i) { 
            for(var key in args[i]) { 
                var simpleExtend = true; 
                if(typeof args[i-1][key] != 'undefined') { 
                    if(typeof args[i][key] == 'object' && typeof args[i-1][key] == 'object') { 
                        if(!isObjectAnArray(args[i]) && !isObjectAnArray(args[i-1])) { 
                            simpleExtend = false; 
                            args[i-1][key] = jDom.extend(args[i-1][key],args[i][key]); 
                        }
                    }
                }
                if(simpleExtend) { 
                    args[i-1][key] = args[i][key]; 
                } 
            }
        } 
        return (args.length) ? args[0] : {}; 
    }; 
    trim = function(str) { 
        return str.replace(/^\s+|\s+$/g,''); 
    }; 
    getKeys = function(obj) { 
        if(Object.keys) { 
            return Object.keys(obj); 
        } else { 
            arr = []; 
            for(var key in obj) { 
                arr.push(key); 
            }
            return arr; 
        }
    }; 
    getArrayFromSpaceSeparated = function(str) { 
        return trim(str).replace(/[ ]+/,' ').split(' ');  
    }; 
    isObjectAnArray = function(obj) { 
        if(Array.isArray) { 
            return Array.isArray(obj); 
        } else { 
            return v instanceof Array; 
        }
    }; 

    /*=========================================================
    |   2) DOM EVENTS:                                        |
    ======================================================== */ 
    var trigger, addEvent; 
    trigger = function(context,eventType) { 
        var event; // The custom event that will be created
        if (d.createEvent) {
            event = d.createEvent("HTMLEvents");
            event.initEvent(eventType, true, true);
        } else {
            event = d.createEventObject();
            event.eventType = eventType;
        }

        event.eventName = eventType;

        if (d.createEvent) {
            context.dispatchEvent(event);
        } else {
            context.fireEvent("on" + event.eventType, event);
        }
        return context;
    }; 
    addEvent = (function( w, d ) { 
        if (d.addEventListener) { 
            return function(elem, type, cb) { 
                if ((elem && !elem.length) || elem === w) { 
                    elem.addEventListener(type, cb, false); 
                } 
                else if (elem && elem.length) { 
                    var len = elem.length; 
                    for (var i = 0; i < len; i++) { 
                        addEvent(elem[i], type, cb); 
                    } 
                } 
            }; 
        } else if (d.attachEvent) { 
            return function (elem, type, cb) { 
                if ((elem && !elem.length) || elem === w) { 
                    elem.attachEvent('on' + type, function() { return cb.call(elem, w.event) }); 
                } 
                else if (elem.length) { 
                    var len = elem.length; 
                    for (var i = 0; i < len; i++) { 
                        addEvent(elem[i], type, cb); 
                    } 
                } 
            }; 
        } 
    })(this, d); 

    /*=========================================================
    |   3) DOM MANIPULATION/CREATION:                         |
    ======================================================== */ 
    var create, creator, createElem; 
    create = function(obj) { 
        return creator(obj); 
    }; 
    creator = function(obj) { 
        var elem, contains, i, contentsObj, innerElem; 
        obj.contains = (obj.contains == null) ? [] : obj.contains; 
        obj.attributes = (obj.attributes == null) ? {} : obj.attributes; 
        obj.bindings = (obj.bindings == null) ? {} : obj.bindings; 
        obj.type = (obj.type == null) ? 'div' : obj.type; 

        elem = createElem(obj.type, obj.attributes, obj.bindings); 
        contains = obj.contains; 

        if(typeof contains == "string") { 
            elem.appendChild(d.createTextNode(contains)); 
        } else { 
            for(i=0; i < contains.length; ++i) {
                contentsObj = contains[i]; 
                if(typeof contentsObj == 'object') { 
                    innerElem = create(contentsObj); 
                    elem.appendChild(innerElem); 
                } else { 
                    elem.appendChild(d.createTextNode(contentsObj)); 
                }
            }
        }
        return elem; 
    }; 
    createElem = function(type, attributes, bindings) {
        var elem, key, val;
        elem = d.createElement(type);
        if (typeof attributes !== "undefined") {
            for (key in attributes) {
                val = attributes[key];
                elem.setAttribute(key, val);
            }
        }
        if(typeof bindings !== "undefined") { 
            for(var key in bindings) { 
                if(typeof bindings[key] == 'function') { 
                    addEvent(elem,key,bindings[key]); 
                }
            }
        }
        return elem;
    };


    /*=========================================================
    |   4) DOM GETTERS/SETTERS:                               |
    ======================================================== */ 
    var getByClassName, getElementsByData, getAttrs, removeClass;
    getByClassName = function(str,context) { 
        var candidates, foundElems = []; 
        candidates = context.getElementsByTagName('*'); 
        str = getArrayFromSpaceSeparated(str); 
        for(var i=0; i < candidates.length; ++i) { 
            var thisClass, compliant = true; 
            thisClass = ' ' + getArrayFromSpaceSeparated(candidates[i].className).join(' ') + ' '; 
            for(var j=0; j < str.length; ++j) { 
                var requirement = ' ' + str[j] + ' '; 
                if(thisClass.indexOf(requirement) == -1) { 
                    compliant = false; 
                    break; 
                }
            }
            if(compliant) { 
                foundElems.push(candidates[i]); 
            }
        }
        return foundElems; 
    }; 
    getElementsByData = function(key,val,context,type) { 
        var candidates, elems = []; 
        candidates = context.getElementsByTagName(type); 
        for(var i=0; i < candidates.length; ++i) { 
            if(candidates[i].getAttribute('data-' + key)) {
                if(val != null) { 
                    if(candidates[i].getAttribute('data-'+key) == val) { 
                        elems.push(candidates[i]); 
                    }
                } else { 
                    elems.push(candidates[i]); 
                }
            }
        }
        return elems; 
    }; 
    getAttrs = function(elem) { 
        var attrs, obj = {}; 
        attrs = elem.attributes; 
        for(var i=0; i < attrs.length; ++i) { 
            var attr = attrs.item(i); 
            obj[attr.nodeName] = attr.nodeValue; 
        }
        return obj; 
    }; 
    removeClass = function(elem,classes) { 
        if(typeof elem.className != "undefined") { 
            var current, numRemovedInner, numRemoved = 0;
            classes = getArrayFromSpaceSeparated(classes); 
            current = getArrayFromSpaceSeparated(elem.className);  
            for(var i=0; i < current.length; ++i) { 
                numRemovedInner = 0; 
                for(var j=0; j < classes.length; ++j) { 
                    if(current[i-numRemoved] == classes[j]) { 
                        current.splice(i-numRemoved,1);
                        classes.splice(j,1); 
                        ++numRemoved; 
                        break; 
                    }
                }
            } 
            elem.className = (current.length) ? current.join(' ') : ""; 
        }
        return elem; 
    }

    // return our public functions: 
    return exports; 
})(jDom || {}, window,document,console); 
jDom = (function(exports,w,d,c){
    var _oldMethod, interpret, interpreter; 
    _oldCreate = exports.create; 

    // Method override: jDom.create()
    exports.create = function(obj) {
        if(typeof obj=='string') { 
            return _oldCreate(interpreter(obj)); 
        } else { 
            return _oldCreate(obj);
        }
    };

    interpret = function(str) { 
        var re, text, attr, type, dotIndex, hashIndex, id, classes; 
        re = { text: /\${([^}]+)}/, attr: /\$\[(.*?)\]/ }  

        // extract text/attrs: ${text}
        text = str.match(re.text); 
        attr = str.match(re.attr); 

        // replace the text and attr strings in original string (if set): 
        if(text) str = str.replace(text[0],''); 
        if(attr) str = str.replace(attr[0],''); 

        // set default type:
        type = 'div'; 
        if(str.length > 0 || attr) { 
            dotIndex = str.indexOf('.'); hashIndex = str.indexOf('#')
            // if we have an element type, find it and remove it from string: 
            if(dotIndex > 0 && hashIndex > 0) { 
                // classes and id's ARE present
                type = str.substring(0,Math.min(dotIndex,hashIndex)); 
                str = str.replace(type,''); 
            } else if(dotIndex < 0 && hashIndex < 0) { 
                // NEITHER the id NOR the class are present
                type = str; 
                str = str.replace(type,''); 
            } else if(dotIndex*hashIndex < 0) { 
                // either an ID or a Class are NOT present (but one is)
                type = str.substring(0,Math.max(dotIndex,hashIndex)); 
                str = str.replace(type,''); 
            } 

            // find any id's or classes: 
            id = false; classes = false; 
            if(str.length > 0) { 
                hashIndex = str.indexOf('#'); 
                if(hashIndex > -1) { 
                    id = str.substring(hashIndex+1,str.length); 
                    dotIndex = id.indexOf('.'); 
                    if(dotIndex > -1) { 
                        id = id.substring(0,dotIndex); 
                    }
                    str = str.replace('#'+id,''); 
                } 
                if(str.length > 0) { 
                    classes = exports.trim(str.split('.').join(' ')); 
                }
            } 

        } else { 
            if(text && !attr) { 
                return text[1]; 
            }
        }

        // interpret attributes: 
        attr = (attr) ? attr[1] : {};
        if(typeof attr == 'string') { 
            var arr = attr.split(','); 
            attr = {}; 
            for(var i=0; i < arr.length; ++i) { 
                var theseattrs = arr[i].split('='); 
                attr[theseattrs[0]] = theseattrs[1]; 
            }
        }  

        // put any ID's classes in as well - we're not doing an extend so they get overwritten: 
        if(id) attr['id'] = id; 
        if(classes) attr['class'] = classes; 

        return { 
            'type': type, 
            'attributes': attr, 
            'contains': (text) ? [text[1]] : []
        }
    } 

    interpreter = function(str) { 
        var levels, currentLevel, obj, plusIndex, starIndex;
        // split on '$>' for hierarchy: 
        levels = str.split('$>'); 
        plusIndex = levels[0].indexOf('$+');
        starIndex = levels[0].indexOf('$*'); 
        if(plusIndex > -1 || starIndex > -1) { 
            // we can't really handle sibling elements ($* || $+) on the base level so if it occurs we're going to wrap in a div
            obj = interpret('div'); 
        } else { 
            // send level1 to interpret() while removing it from [levels]
            obj = interpret(levels.splice(0,1)[0]); 
        }
        var currobj = obj; 
        // perform recursive calls for deeper-level elements: 
        for(var i=0; i < levels.length; ++i) { 
            var siblings = levels[i].split('$+'); 
            for(var j=0; j < siblings.length; ++j) { 
                starIndex = siblings[j].indexOf('$*'); 
                if(starIndex > -1) { 
                    // get multiplier (if exists) and remove from string: 
                    var multiplier = parseInt(siblings[j].substring(starIndex+2,siblings[j].length)); 
                    siblings[j] = siblings[j].replace('$*'+multiplier,''); 
                    for(var k=0; k < multiplier; ++k) { 
                        currobj.contains.push(interpreter(siblings[j])); 
                    } 
                } else { 
                    currobj.contains.push(interpreter(siblings[j]));
                }
            } 
            currobj = obj.contains[obj.contains.length-1]
        } 
        return obj; 
    } 

    // return our public functions: 
    return exports; 
})(jDom || {}, window,document,console); 
var theApptPicker = (function(w,d,c){
    var createPicker, makeLists, init, state, defaults, handlePickerBtnClick, handleBaseTimeClick, applyMiddleClasses, 
        handleSecondaryTimeClick, handleSecondaryHover, fixtimingorder, reportChange, registerCallback, wireCallback, 
        scrollTopKey, animateScrollTop, endAnimateScrollTop; 

    state = { 
        count: 0,
        pickers: { }
    }; 

    defaults = { 
        start: '9:00am', 
        end: '5:00pm', 
        subinterval: 60,
        interval: 15, 
        slidedur: 280, 
        opendur: 300, 
        height: '351px', 
        opentext: 'Choose Times', 
        inputid: false, 
        changecallback: false, 
        expandcallback: false, 
        changetxt: true 
    }; 
    
    makeLists = function(times, exact) { 
        exact = (typeof exact == 'undefined') ? false : true; 
        var contains, obj, lim; 
        contains = [ ]; 
        lim = (exact) ? times.length : times.length -1; 
        for(var i=0; i < lim; ++i) {
            var str, bindings = { }, attrs = { };
            if(exact) { 
                str = timeUtils.formatTimeStr(times[i]); 
                attrs['data-time'] = times[i].getTime(); 
                bindings['click'] = handleSecondaryTimeClick; 
                bindings['mouseover'] = handleSecondaryHover; 
            } else { 
                str = timeUtils.formatTimeStr(times[i], true) + " - " + 
                      timeUtils.formatTimeStr(times[i+1],true); 
                attrs['data-start'] = times[i].getTime(); 
                attrs['data-end'] = times[i+1].getTime();
                bindings['click'] = handleBaseTimeClick; 
            }
            attrs['data-listindex'] = i; 
            contains.push({
                type: 'li', 
                attributes: attrs, 
                bindings: bindings,
                contains: str
            });
        }
        var bindings = {}; 
        if(exact) { 
            var bindings = {
                webkitTransitionEnd: endAnimateScrollTop, 
                oTransitionEnd: endAnimateScrollTop, 
                transitionend: endAnimateScrollTop
            }; 
        }
        obj = { 
            type: 'div', 
            attributes: {'class': 'list-container'}, 
            bindings: bindings,
            contains: [
                {
                    type: 'ul', 
                    attributes: { 'class': (exact) ? 'appt-picker second' : 'appt-picker first' }, 
                    contains: contains
                }
            ]
        }
        return jDom.create(obj); 
    }; 
    
    createPicker = function(el) { 
        var settings, picker, tlarge, tsmall; 
        settings = jDom.extend({},defaults,jDom.getData(el))
        tlarge = timeUtils.getTimes(settings.start,settings.end,settings.subinterval); 
        tsmall = timeUtils.getTimes(settings.start,settings.end,settings.interval);
        tlarge = makeLists(tlarge); 
        tsmall = makeLists(tsmall,true);
        el.appendChild(tlarge); 
        el.appendChild(tsmall);  
        el.setAttribute('data-pickerid','picker_'+state.count); 
        settings.minimizedheight = el.offsetHeight + 'px'; 

        if(settings.inputid != false) { 
            settings.input = d.getElementById(settings.inputid); 
            if(settings.input) { 
                settings.input.setAttribute('data-pickerid', 'picker_'+state.count); 
                settings.input.setAttribute('readonly','true');
                jDom.on(settings.input, 'focus', handlePickerBtnClick);                 
            }
        }

        state.pickers['picker_'+state.count] = { 
            el: el, 
            minimized: true,
            expanded: false, 
            selecting: false, 
            start: false, 
            end: false, 
            startindex: 0,
            endindex: 0, 
            lasthoverindex: -1, 
            settings: settings, 
        }; 
        ++state.count; 
    }; 
    
    handlePickerBtnClick = function() { 
        var id = this.getAttribute('data-pickerid'); 
        if(state.pickers[id].el.offsetHeight < parseFloat(state.pickers[id].settings.height)) { 
            var targetHeight = state.pickers[id].settings.height; 
            state.pickers[id].minimized = false; 
        } else { 
            var targetHeight = state.pickers[id].settings.minimizedheight; 
            state.pickers[id].minimized = true; 
        }
        state.pickers[id].el.style.height = targetHeight; 
    }; 
    
    endAnimateScrollTop = function() {
        var list, offset; 
        list = this.getElementsByTagName('ul')[0]; 
        jDom.removeClass(list,'scrollTop'); 
        offset = this.getAttribute('data-scrolltop'); 
        list.style.marginTop = '0px'; 
        this.scrollTop = offset; 
    }; 

    animateScrollTop = function(elem,id,top) { 
        var curr = elem.parentNode.scrollTop; 
        if(top != curr) { 
            jDom.addClass(elem,'scrollTop'); 
            elem.parentNode.setAttribute('data-scrolltop', top); 
            elem.style.marginTop = (curr - top) + "px"; 
        }
    }; 

    handleBaseTimeClick = function() { 
        var list, container, secondarylist, start, id, y; 
        list = this.parentNode; 
        container = list.parentNode.parentNode; 
        secondarylist = container.getElementsByTagName('ul')[1]; 
        id = container.getAttribute('data-pickerid');
        
        start = this.getAttribute('data-start'); 

        jDom.removeClass(jDom.getByClassName('appt-picker first')[0].getElementsByTagName('li'), 'active', false); 

        jDom.addClass(this,'active'); 
    
        if(!state.pickers[id].expanded) {
            state.pickers[id].expanded = true; 
            list.style.width = '40%';  
        }
    
        y = jDom.getElementsByData('time',start,container,'li')[0].offsetTop; 
        animateScrollTop(secondarylist,id,y); 
        // secondarylist.style.marginTop = ((-1)*y)+ "px"; 
    }; 
    
    applyMiddleClasses = function(list,a,b) { 
        var arr, start, end; 
        arr = list.getElementsByTagName('li'); 
        start = Math.min(a,b); 
        end = Math.max(a,b); 
        if(a-b!=0) { 
            jDom.removeClass(arr,'pick-start pick-middle pick-end', false); 
            for(var i=start+1; i < end; ++i) { 
                jDom.addClass(arr[i],'pick-middle'); 
            }    
            jDom.addClass(arr[start],'pick-start'); 
            jDom.addClass(arr[end],'pick-end'); 
        }
    }; 
    
    fixtimingorder = function(id) { 
        var small, large, intermediate; 
        if(state.pickers[id].start > state.pickers[id].end) { 
            intermediate = state.pickers[id].start; 
            state.pickers[id].start = state.pickers[id].end; 
            state.pickers[id].end = intermediate; 
        }
    }; 
    
    handleSecondaryTimeClick = function() { 
        var list, container, time, id; 
        list = this.parentNode; 
        container = list.parentNode.parentNode; 
        id = container.getAttribute('data-pickerid'); 
        time = new Date(parseFloat(this.getAttribute('data-time'))); 
        if(state.pickers[id].selecting == false) { 
            // selecting the first date:  
            state.pickers[id].selecting = true; 
            state.pickers[id].end = false; 
            state.pickers[id].start = time
            state.pickers[id].startindex = this.getAttribute('data-listindex'); 
            jDom.removeClass(list.getElementsByTagName('li'),'pick-start pick-middle pick-end',false); 
            jDom.addClass(this,'pick-start'); 
            reportChange(id); 
        } else { 
            if(this.getAttribute('data-listindex') != state.pickers[id].startindex) { 
                // selecting the second date: 
                state.pickers[id].selecting = false; 
                state.pickers[id].end = time; 
                state.pickers[id].endindex = this.getAttribute('data-listindex'); 
                applyMiddleClasses(list,state.pickers[id].startindex,state.pickers[id].endindex); 
                jDom.trigger(state.pickers[id].settings.input,'click'); 
                if(state.pickers[id].settings.inputid) { 
                    fixtimingorder(id); 
                    var str = timeUtils.formatTimeStr(state.pickers[id].start) + " to " + 
                                timeUtils.formatTimeStr(state.pickers[id].end); 
                    var arr = [ state.pickers[id].start.toISOString(), state.pickers[id].end.toISOString()]; 
                    c.log(arr.join(',')); 
                    d.getElementById(state.pickers[id].settings.inputid).value = str;
                }
            }
            reportChange(id); 
        }
    }; 
    
    handleSecondaryHover = function() { 
        var id, curr, list;
        list = this.parentNode; 
        id = list.parentNode.parentNode.getAttribute('data-pickerid'); 
        curr = this.getAttribute('data-listindex'); 
        if(state.pickers[id].selecting && state.pickers[id].lasthoverindex != curr) {
            state.pickers[id].lasthoverindex = curr;
            if(state.pickers[id].startindex != curr) { 
                applyMiddleClasses(list,state.pickers[id].startindex,curr); 
            } else { 
                // we are hovering the starting time <li> : 
                jDom.removeClass(list.getElementsByTagName('li'),'pick-start pick-middle pick-end', false); 
                jDom.addClass(this,'pick-start'); 
            }
        }
    }; 

    reportChange = function(id) { 
        if(state.pickers[id].settings.changecallback) { 
            state.pickers[id].settings.changecallback(state.pickers[id]); 
        }
        if(state.pickers[id].settings.changetxt) { 
            var str = ""; 
            str = timeUtils.formatTimeStr(state.pickers[id].start) + " to " + timeUtils.formatTimeStr(state.pickers[id].end); 
        }
    }; 
    
    wireCallback = function(el,type,func) { 
        var validfunc = false 
        validfunc = (typeof func == 'function') ? true : false; 
        if(typeof window[func] != 'undefined') { 
            if(typeof window[func] == 'function') { 
                validfunc = true;
                func = window[func];  
            }
        }
        if(validfunc) { 
            var id = el.getAttribute('data-pickerid'); 
            if(typeof state.pickers[id] != 'undefined') { 
                switch(type.toLowerCase()) { 
                    case 'expand': 
                        state.pickers[id].settings.expandcallback = func; 
                        break; 
                    case 'change': 
                        state.pickers[id].settings.changecallback = func; 
                        break; 
                }
            }
        }
    }
    
    init = function() { 
        var elems = jDom.getByClassName('apptPicker'); 
        for(var i=0; i < elems.length; ++i) { 
            createPicker(elems[i]); 
        }
    };

    /* Public Methods: */
    w.apptPicker = function(id) { 
        var on, create, getTimes, expand, el, pickerid; 
        el = d.getElementById(id); 
        pickerid = el.getAttribute('data-pickerid'); 
        
        on = function(type,func) {
            if(el) { 
                wireCallback(el,type,func); 
                return apptPicker(id); 
            }
        }; 

        getTimes = function(type,func) { 
            if(typeof state.pickers[pickerid] != 'undefined') { 
                if(!state.pickers[pickerid].start || !state.pickers[pickerid].end) { 
                    return false; 
                } else { 
                    return { 
                        start: state.pickers[pickerid].start, 
                        end: state.pickers[pickerid].end
                    }
                }
            } else { 
                return false; 
            }
        }; 

        create = function(opts) {
            if(el) { 
                for(var key in opts) { 
                    el.setAttribute('data-'+key, opts[key]); 
                }
                if(!pickerid) { 
                    createPicker(el); 
                    return apptPicker(el.getAttribute('id')); 
                } else { 
                    return apptPicker(el.getAttribute('id')); 
                }
            }
        }; 

        toggleOpen = function() { 
            if(typeof pickerid != 'undefined') {
                jDom.trigger(state.pickers[pickerid].settings.input, 'click'); 
                return apptPicker(el.getAttribute('id')); 
            }
        }; 

        return { 
            on: on, 
            getTimes: getTimes, 
            create: create, 
            toggleOpen: toggleOpen
        }
    };

    // go! go! go! 
    jDom.ready(init);
    
})(window,document,console); 